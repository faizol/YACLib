<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YACLib: yaclib Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YACLib
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ library for concurrent tasks execution</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceyaclib.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">yaclib Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceyaclib_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1Future.html">Future</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a mechanism to access the result of async operations.  <a href="classyaclib_1_1Future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IFunc.html">IFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared callable interface.  <a href="classyaclib_1_1IFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1Inline.html">Inline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A intrusive pointer to objects with an embedded reference count.  <a href="classyaclib_1_1IntrusivePtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IRef.html">IRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting interface.  <a href="classyaclib_1_1IRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1ITask.html">ITask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable that can be executed in an <a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a>.  <a href="classyaclib_1_1ITask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IThread.html">IThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IThreadFactory.html">IThreadFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1IThreadPool.html">IThreadPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classInterface.html">Interface</a> for thread-pool-like executors.  <a href="classyaclib_1_1IThreadPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyaclib_1_1NoRefTag.html">NoRefTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1Promise.html">Promise</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1Result.html">Result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulated return value from caller.  <a href="classyaclib_1_1Result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyaclib_1_1ResultEmpty.html">ResultEmpty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1ResultError.html">ResultError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyaclib_1_1StopError.html">StopError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default error.  <a href="structyaclib_1_1StopError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyaclib_1_1StopTag.html">StopTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyaclib_1_1Unit.html">Unit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal instead of void usage.  <a href="structyaclib_1_1Unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyaclib_1_1WaitGroup.html">WaitGroup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac7d7025bade30573019dc58b09e29fd0"><td class="memTemplParams" colspan="2">template&lt;typename V , typename E &gt; </td></tr>
<tr class="memitem:ac7d7025bade30573019dc58b09e29fd0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ac7d7025bade30573019dc58b09e29fd0">Contract</a> = std::pair&lt; <a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; V, E &gt;, <a class="el" href="classyaclib_1_1Promise.html">Promise</a>&lt; V, E &gt; &gt;</td></tr>
<tr class="memdesc:ac7d7025bade30573019dc58b09e29fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes channel with future and promise.  <a href="namespaceyaclib.html#ac7d7025bade30573019dc58b09e29fd0">More...</a><br /></td></tr>
<tr class="separator:ac7d7025bade30573019dc58b09e29fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb00951a7b082d1c3069a02f12713018"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a> = <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; <a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a> &gt;</td></tr>
<tr class="separator:aeb00951a7b082d1c3069a02f12713018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c3cb3b321f85b6e96b47e50f6e0b0d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a85c3cb3b321f85b6e96b47e50f6e0b0d">IThreadPtr</a> = <a class="el" href="classyaclib_1_1IThread.html">IThread</a> *</td></tr>
<tr class="separator:a85c3cb3b321f85b6e96b47e50f6e0b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19c41352ffc16128cc00318a4f8615c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> = <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; <a class="el" href="classyaclib_1_1IThreadFactory.html">IThreadFactory</a> &gt;</td></tr>
<tr class="separator:ae19c41352ffc16128cc00318a4f8615c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab039debaa8307cdefe0c03481b1bf3da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ab039debaa8307cdefe0c03481b1bf3da">IThreadPoolPtr</a> = <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; <a class="el" href="classyaclib_1_1IThreadPool.html">IThreadPool</a> &gt;</td></tr>
<tr class="separator:ab039debaa8307cdefe0c03481b1bf3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f01e961fd6af87d533ea57d67d9f1f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aa0f01e961fd6af87d533ea57d67d9f1f">LogCallback</a> = void(*)(std::string_view file, std::size_t line, std::string_view function, std::string_view condition, std::string_view message)</td></tr>
<tr class="separator:aa0f01e961fd6af87d533ea57d67d9f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4f817f4403d420b1975cce677577c2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#acc4f817f4403d420b1975cce677577c2">IFuncPtr</a> = <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; <a class="el" href="classyaclib_1_1IFunc.html">IFunc</a> &gt;</td></tr>
<tr class="separator:acc4f817f4403d420b1975cce677577c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23af97c15e210af60f48dba5fa3736b7"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a23af97c15e210af60f48dba5fa3736b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a23af97c15e210af60f48dba5fa3736b7">head_t</a> = typename <a class="el" href="structyaclib_1_1detail_1_1Head.html">detail::Head</a>&lt; Args... &gt;::Type</td></tr>
<tr class="separator:a23af97c15e210af60f48dba5fa3736b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af445c7d079358d21fa8defe06ee4ac1c"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Arg&gt; </td></tr>
<tr class="memitem:af445c7d079358d21fa8defe06ee4ac1c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#af445c7d079358d21fa8defe06ee4ac1c">invoke_t</a> = typename <a class="el" href="structyaclib_1_1detail_1_1Invoke.html">detail::Invoke</a>&lt; Functor, Arg... &gt;::Type</td></tr>
<tr class="separator:af445c7d079358d21fa8defe06ee4ac1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8180a184a21b384fe5c6c35eb5bb9f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adc8180a184a21b384fe5c6c35eb5bb9f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#adc8180a184a21b384fe5c6c35eb5bb9f">result_value_t</a> = typename <a class="el" href="structyaclib_1_1detail_1_1InstantiationTypes.html">detail::InstantiationTypes</a>&lt; <a class="el" href="classyaclib_1_1Result.html">Result</a>, T &gt;::Value</td></tr>
<tr class="separator:adc8180a184a21b384fe5c6c35eb5bb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47bee250bfd56f471dc072f0f5be0fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae47bee250bfd56f471dc072f0f5be0fc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ae47bee250bfd56f471dc072f0f5be0fc">result_error_t</a> = typename <a class="el" href="structyaclib_1_1detail_1_1InstantiationTypes.html">detail::InstantiationTypes</a>&lt; <a class="el" href="classyaclib_1_1Result.html">Result</a>, T &gt;::Error</td></tr>
<tr class="separator:ae47bee250bfd56f471dc072f0f5be0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d12f23257fc6bdd425efef19966548"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02d12f23257fc6bdd425efef19966548"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a02d12f23257fc6bdd425efef19966548">future_value_t</a> = typename <a class="el" href="structyaclib_1_1detail_1_1InstantiationTypes.html">detail::InstantiationTypes</a>&lt; <a class="el" href="classyaclib_1_1Future.html">Future</a>, T &gt;::Value</td></tr>
<tr class="separator:a02d12f23257fc6bdd425efef19966548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a8bd10224b9153070612f2e21e7dd4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a83a8bd10224b9153070612f2e21e7dd4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a83a8bd10224b9153070612f2e21e7dd4">future_error_t</a> = typename <a class="el" href="structyaclib_1_1detail_1_1InstantiationTypes.html">detail::InstantiationTypes</a>&lt; <a class="el" href="classyaclib_1_1Future.html">Future</a>, T &gt;::Error</td></tr>
<tr class="separator:a83a8bd10224b9153070612f2e21e7dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a59284220f851121992ca16d23bc968dc"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dc">WhenPolicy</a> { <a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dca6adf97f83acf6453d4a6a4b1070f3754">None</a>
, <a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dca1a5d257dfef0fee3c8b56cdcc2de854b">FirstFail</a>
, <a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dca390c1dbd73f79789d71c350562508932">LastFail</a>
 }</td></tr>
<tr class="memdesc:a59284220f851121992ca16d23bc968dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Policy describe how When* algorithm interpret if Future will be fulfilled by error or exception.  <a href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dc">More...</a><br /></td></tr>
<tr class="separator:a59284220f851121992ca16d23bc968dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931c767f78cbcd6634cbedbddf405017"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a931c767f78cbcd6634cbedbddf405017">ResultState</a> : char { <a class="el" href="namespaceyaclib.html#a931c767f78cbcd6634cbedbddf405017a689202409e48743b914713f96d93947c">Value</a> = 0
, <a class="el" href="namespaceyaclib.html#a931c767f78cbcd6634cbedbddf405017ab0d4998a26f5b5742ad38c4af8817e32">Exception</a> = 1
, <a class="el" href="namespaceyaclib.html#a931c767f78cbcd6634cbedbddf405017a902b0d55fddef6f8d651fe1035b7d4bd">Error</a> = 2
, <a class="el" href="namespaceyaclib.html#a931c767f78cbcd6634cbedbddf405017ace2c8aed9c2fa0cfbed56cbda4d8bf07">Empty</a> = 3
 }</td></tr>
<tr class="separator:a931c767f78cbcd6634cbedbddf405017"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a027cc00296224d649cadb5f0107761d8"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::DefaultEvent, typename... V, typename... E&gt; </td></tr>
<tr class="memitem:a027cc00296224d649cadb5f0107761d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a027cc00296224d649cadb5f0107761d8">Wait</a> (<a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; V, E &gt; &amp;... fs)</td></tr>
<tr class="memdesc:a027cc00296224d649cadb5f0107761d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until Ready becomes true.  <a href="namespaceyaclib.html#a027cc00296224d649cadb5f0107761d8">More...</a><br /></td></tr>
<tr class="separator:a027cc00296224d649cadb5f0107761d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcc3780c2cb12e6b0876b5866c99101"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::DefaultEvent, typename It &gt; </td></tr>
<tr class="memitem:a3bcc3780c2cb12e6b0876b5866c99101"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#acf5a091f19cc9cd3aea766425d16a480">is_future_v</a>&lt; It &gt;, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a3bcc3780c2cb12e6b0876b5866c99101">Wait</a> (It begin, It end)</td></tr>
<tr class="memdesc:a3bcc3780c2cb12e6b0876b5866c99101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until Ready becomes true.  <a href="namespaceyaclib.html#a3bcc3780c2cb12e6b0876b5866c99101">More...</a><br /></td></tr>
<tr class="separator:a3bcc3780c2cb12e6b0876b5866c99101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac104c3932bffca9c5e21f743229d4356"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::DefaultEvent, typename It &gt; </td></tr>
<tr class="memitem:ac104c3932bffca9c5e21f743229d4356"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ac104c3932bffca9c5e21f743229d4356">Wait</a> (It begin, std::size_t size)</td></tr>
<tr class="memdesc:ac104c3932bffca9c5e21f743229d4356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until Ready becomes true.  <a href="namespaceyaclib.html#ac104c3932bffca9c5e21f743229d4356">More...</a><br /></td></tr>
<tr class="separator:ac104c3932bffca9c5e21f743229d4356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac255d7c2eb95767b15dc77ff93b0a661"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::MutexEvent, typename Rep , typename Period , typename... V, typename... E&gt; </td></tr>
<tr class="memitem:ac255d7c2eb95767b15dc77ff93b0a661"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ac255d7c2eb95767b15dc77ff93b0a661">WaitFor</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout_duration, <a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; V, E &gt; &amp;... fs)</td></tr>
<tr class="memdesc:ac255d7c2eb95767b15dc77ff93b0a661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified timeout duration has elapsed or Ready becomes true.  <a href="namespaceyaclib.html#ac255d7c2eb95767b15dc77ff93b0a661">More...</a><br /></td></tr>
<tr class="separator:ac255d7c2eb95767b15dc77ff93b0a661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b6e206b4df56f0b8d8950f8730251a"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::MutexEvent, typename Rep , typename Period , typename Iterator &gt; </td></tr>
<tr class="memitem:a80b6e206b4df56f0b8d8950f8730251a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#acf5a091f19cc9cd3aea766425d16a480">is_future_v</a>&lt; Iterator &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a80b6e206b4df56f0b8d8950f8730251a">WaitFor</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout_duration, Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:a80b6e206b4df56f0b8d8950f8730251a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified timeout duration has elapsed or Ready becomes true.  <a href="namespaceyaclib.html#a80b6e206b4df56f0b8d8950f8730251a">More...</a><br /></td></tr>
<tr class="separator:a80b6e206b4df56f0b8d8950f8730251a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540ed994451410e0a026fa350530d598"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::MutexEvent, typename Rep , typename Period , typename Iterator &gt; </td></tr>
<tr class="memitem:a540ed994451410e0a026fa350530d598"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a540ed994451410e0a026fa350530d598">WaitFor</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout_duration, Iterator begin, std::size_t size)</td></tr>
<tr class="memdesc:a540ed994451410e0a026fa350530d598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified timeout duration has elapsed or Ready becomes true.  <a href="namespaceyaclib.html#a540ed994451410e0a026fa350530d598">More...</a><br /></td></tr>
<tr class="separator:a540ed994451410e0a026fa350530d598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369fd18e0340bec757b9f84e50e4026a"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::MutexEvent, typename Clock , typename Duration , typename... V, typename... E&gt; </td></tr>
<tr class="memitem:a369fd18e0340bec757b9f84e50e4026a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a369fd18e0340bec757b9f84e50e4026a">WaitUntil</a> (const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout_time, <a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; V, E &gt; &amp;... fs)</td></tr>
<tr class="memdesc:a369fd18e0340bec757b9f84e50e4026a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until specified time has been reached or Ready becomes true.  <a href="namespaceyaclib.html#a369fd18e0340bec757b9f84e50e4026a">More...</a><br /></td></tr>
<tr class="separator:a369fd18e0340bec757b9f84e50e4026a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925b6c58aa4d3ee845f3177798f5feb2"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::MutexEvent, typename Clock , typename Duration , typename Iterator &gt; </td></tr>
<tr class="memitem:a925b6c58aa4d3ee845f3177798f5feb2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#acf5a091f19cc9cd3aea766425d16a480">is_future_v</a>&lt; Iterator &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a925b6c58aa4d3ee845f3177798f5feb2">WaitUntil</a> (const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout_time, Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:a925b6c58aa4d3ee845f3177798f5feb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until specified time has been reached or Ready becomes true.  <a href="namespaceyaclib.html#a925b6c58aa4d3ee845f3177798f5feb2">More...</a><br /></td></tr>
<tr class="separator:a925b6c58aa4d3ee845f3177798f5feb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7901ebb91c58d92a568ea9c4202110c"><td class="memTemplParams" colspan="2">template&lt;typename Event  = detail::MutexEvent, typename Clock , typename Duration , typename Iterator &gt; </td></tr>
<tr class="memitem:ac7901ebb91c58d92a568ea9c4202110c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ac7901ebb91c58d92a568ea9c4202110c">WaitUntil</a> (const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout_time, Iterator begin, std::size_t size)</td></tr>
<tr class="memdesc:ac7901ebb91c58d92a568ea9c4202110c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until specified time has been reached or Ready becomes true.  <a href="namespaceyaclib.html#ac7901ebb91c58d92a568ea9c4202110c">More...</a><br /></td></tr>
<tr class="separator:ac7901ebb91c58d92a568ea9c4202110c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6265977faa9740c1b860d0ca400fbf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dc">WhenPolicy</a> P = WhenPolicy::FirstFail, typename It , typename T  = typename std::iterator_traits&lt;It&gt;::value_type&gt; </td></tr>
<tr class="memitem:a0c6265977faa9740c1b860d0ca400fbf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a0c6265977faa9740c1b860d0ca400fbf">WhenAll</a> (It begin, std::size_t size)</td></tr>
<tr class="memdesc:a0c6265977faa9740c1b860d0ca400fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready.  <a href="namespaceyaclib.html#a0c6265977faa9740c1b860d0ca400fbf">More...</a><br /></td></tr>
<tr class="separator:a0c6265977faa9740c1b860d0ca400fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d72251d76812a53dcc72a0c8dc2707"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dc">WhenPolicy</a> P = WhenPolicy::FirstFail, typename It , typename T  = typename std::iterator_traits&lt;It&gt;::value_type&gt; </td></tr>
<tr class="memitem:a10d72251d76812a53dcc72a0c8dc2707"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a10d72251d76812a53dcc72a0c8dc2707">WhenAll</a> (It begin, It end)</td></tr>
<tr class="memdesc:a10d72251d76812a53dcc72a0c8dc2707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready.  <a href="namespaceyaclib.html#a10d72251d76812a53dcc72a0c8dc2707">More...</a><br /></td></tr>
<tr class="separator:a10d72251d76812a53dcc72a0c8dc2707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4152a573b6c3b13e988d675cd15ad4d4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dc">WhenPolicy</a> P = WhenPolicy::FirstFail, typename V , typename E , typename... Vs, typename... Es&gt; </td></tr>
<tr class="memitem:a4152a573b6c3b13e988d675cd15ad4d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a4152a573b6c3b13e988d675cd15ad4d4">WhenAll</a> (<a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; V, E &gt; &amp;&amp;head, <a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; Vs, Es &gt; &amp;&amp;... tail)</td></tr>
<tr class="memdesc:a4152a573b6c3b13e988d675cd15ad4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready.  <a href="namespaceyaclib.html#a4152a573b6c3b13e988d675cd15ad4d4">More...</a><br /></td></tr>
<tr class="separator:a4152a573b6c3b13e988d675cd15ad4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f7913770512400e0808d23065cf6ea"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dc">WhenPolicy</a> P = WhenPolicy::LastFail, typename It , typename T  = typename std::iterator_traits&lt;It&gt;::value_type&gt; </td></tr>
<tr class="memitem:ab4f7913770512400e0808d23065cf6ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ab4f7913770512400e0808d23065cf6ea">WhenAny</a> (It begin, std::size_t size)</td></tr>
<tr class="memdesc:ab4f7913770512400e0808d23065cf6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready.  <a href="namespaceyaclib.html#ab4f7913770512400e0808d23065cf6ea">More...</a><br /></td></tr>
<tr class="separator:ab4f7913770512400e0808d23065cf6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8888500725b47abf63d9a187311e5501"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dc">WhenPolicy</a> P = WhenPolicy::LastFail, typename It , typename T  = typename std::iterator_traits&lt;It&gt;::value_type&gt; </td></tr>
<tr class="memitem:a8888500725b47abf63d9a187311e5501"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a8888500725b47abf63d9a187311e5501">WhenAny</a> (It begin, It end)</td></tr>
<tr class="memdesc:a8888500725b47abf63d9a187311e5501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready.  <a href="namespaceyaclib.html#a8888500725b47abf63d9a187311e5501">More...</a><br /></td></tr>
<tr class="separator:a8888500725b47abf63d9a187311e5501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cefe429f3566431baa0f27b02f6935"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dc">WhenPolicy</a> P = WhenPolicy::LastFail, typename V , typename E , typename... Vs, typename Es &gt; </td></tr>
<tr class="memitem:ae3cefe429f3566431baa0f27b02f6935"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; V, E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ae3cefe429f3566431baa0f27b02f6935">WhenAny</a> (<a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; V, E &gt; &amp;&amp;head, <a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; Vs, Es &gt; &amp;&amp;... tail)</td></tr>
<tr class="memdesc:ae3cefe429f3566431baa0f27b02f6935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready.  <a href="namespaceyaclib.html#ae3cefe429f3566431baa0f27b02f6935">More...</a><br /></td></tr>
<tr class="separator:ae3cefe429f3566431baa0f27b02f6935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac918e7a0c384bcf611e0b5b4b2cd5504"><td class="memTemplParams" colspan="2">template&lt;typename V , typename E  = StopError&gt; </td></tr>
<tr class="memitem:ac918e7a0c384bcf611e0b5b4b2cd5504"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#ac7d7025bade30573019dc58b09e29fd0">Contract</a>&lt; V, E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ac918e7a0c384bcf611e0b5b4b2cd5504">MakeContract</a> ()</td></tr>
<tr class="memdesc:ac918e7a0c384bcf611e0b5b4b2cd5504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates related future and promise.  <a href="namespaceyaclib.html#ac918e7a0c384bcf611e0b5b4b2cd5504">More...</a><br /></td></tr>
<tr class="separator:ac918e7a0c384bcf611e0b5b4b2cd5504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf4462ab5b93960f89cee782fdb67a5"><td class="memTemplParams" colspan="2">template&lt;typename V  = Unit, typename E  = StopError, typename... Args&gt; </td></tr>
<tr class="memitem:abaf4462ab5b93960f89cee782fdb67a5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#abaf4462ab5b93960f89cee782fdb67a5">MakeFuture</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:abaf4462ab5b93960f89cee782fdb67a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1842c635072fa265d437b4f21b91287f"><td class="memTemplParams" colspan="2">template&lt;typename E  = StopError, typename Functor &gt; </td></tr>
<tr class="memitem:a1842c635072fa265d437b4f21b91287f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a1842c635072fa265d437b4f21b91287f">Run</a> (const <a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a> &amp;e, Functor &amp;&amp;f)</td></tr>
<tr class="memdesc:a1842c635072fa265d437b4f21b91287f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute Callable functor via executor.  <a href="namespaceyaclib.html#a1842c635072fa265d437b4f21b91287f">More...</a><br /></td></tr>
<tr class="separator:a1842c635072fa265d437b4f21b91287f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d4007c8e7b7cc6d37389ac5c1806fa"><td class="memTemplParams" colspan="2">template&lt;typename... V, typename... E&gt; </td></tr>
<tr class="memitem:a97d4007c8e7b7cc6d37389ac5c1806fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classyaclib_1_1detail_1_1FutureAwaiter.html">detail::FutureAwaiter</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a97d4007c8e7b7cc6d37389ac5c1806fa">Await</a> (<a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; V, E &gt; &amp;... fs)</td></tr>
<tr class="separator:a97d4007c8e7b7cc6d37389ac5c1806fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9d19b82b05068a634f6557f83c1fa7"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:aef9d19b82b05068a634f6557f83c1fa7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#acf5a091f19cc9cd3aea766425d16a480">is_future_v</a>&lt; Iterator &gt;, <a class="el" href="classyaclib_1_1detail_1_1FutureAwaiter.html">detail::FutureAwaiter</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aef9d19b82b05068a634f6557f83c1fa7">Await</a> (Iterator begin, Iterator end)</td></tr>
<tr class="separator:aef9d19b82b05068a634f6557f83c1fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad503b0971a037bbd04d444e81a5e0150"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ad503b0971a037bbd04d444e81a5e0150"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#acf5a091f19cc9cd3aea766425d16a480">is_future_v</a>&lt; Iterator &gt;, <a class="el" href="classyaclib_1_1detail_1_1FutureAwaiter.html">detail::FutureAwaiter</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ad503b0971a037bbd04d444e81a5e0150">Await</a> (Iterator begin, std::size_t count)</td></tr>
<tr class="separator:ad503b0971a037bbd04d444e81a5e0150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab247a06a303af6a2234d2247eb0d1e55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ab247a06a303af6a2234d2247eb0d1e55">MakeInline</a> () noexcept</td></tr>
<tr class="memdesc:ab247a06a303af6a2234d2247eb0d1e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classyaclib_1_1Inline.html">Inline</a> executor singleton object.  <a href="namespaceyaclib.html#ab247a06a303af6a2234d2247eb0d1e55">More...</a><br /></td></tr>
<tr class="separator:ab247a06a303af6a2234d2247eb0d1e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7d050cd191bf12f4b29b3f97050c83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a7f7d050cd191bf12f4b29b3f97050c83">MakeStrand</a> (<a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a> e)</td></tr>
<tr class="memdesc:a7f7d050cd191bf12f4b29b3f97050c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strand is the asynchronous analogue of a mutex.  <a href="namespaceyaclib.html#a7f7d050cd191bf12f4b29b3f97050c83">More...</a><br /></td></tr>
<tr class="separator:a7f7d050cd191bf12f4b29b3f97050c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010f2552afaa6ac89c77820c957c2cd0"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a010f2552afaa6ac89c77820c957c2cd0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a010f2552afaa6ac89c77820c957c2cd0">Submit</a> (const <a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a> &amp;executor, Functor &amp;&amp;f)</td></tr>
<tr class="memdesc:a010f2552afaa6ac89c77820c957c2cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit given functor for details.  <a href="namespaceyaclib.html#a010f2552afaa6ac89c77820c957c2cd0">More...</a><br /></td></tr>
<tr class="separator:a010f2552afaa6ac89c77820c957c2cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6470522549981a792f7a073772ff9c57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a6470522549981a792f7a073772ff9c57">MakeThreadFactory</a> (std::size_t cache=0)</td></tr>
<tr class="separator:a6470522549981a792f7a073772ff9c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba22a625dc73cea7f6310d6e6147aa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a0ba22a625dc73cea7f6310d6e6147aa3">MakeThreadFactory</a> (<a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> base, std::string_view name)</td></tr>
<tr class="separator:a0ba22a625dc73cea7f6310d6e6147aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58431cd89c902b17a1f386e2be4f4d33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a58431cd89c902b17a1f386e2be4f4d33">MakeThreadFactory</a> (<a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> base, std::size_t priority)</td></tr>
<tr class="separator:a58431cd89c902b17a1f386e2be4f4d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3348b06a8925f35eb031e9563b1980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a3a3348b06a8925f35eb031e9563b1980">MakeThreadFactory</a> (<a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> base, <a class="el" href="namespaceyaclib.html#acc4f817f4403d420b1975cce677577c2">IFuncPtr</a> acquire, <a class="el" href="namespaceyaclib.html#acc4f817f4403d420b1975cce677577c2">IFuncPtr</a> release)</td></tr>
<tr class="separator:a3a3348b06a8925f35eb031e9563b1980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e27483f912682aad998898f42b775f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classyaclib_1_1IThreadPool.html">IThreadPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a60e27483f912682aad998898f42b775f">CurrentThreadPool</a> () noexcept</td></tr>
<tr class="separator:a60e27483f912682aad998898f42b775f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd02a3297ea3c5b6de6144c3b993d6f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#ab039debaa8307cdefe0c03481b1bf3da">IThreadPoolPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#abd02a3297ea3c5b6de6144c3b993d6f6">MakeThreadPool</a> (std::size_t threads=std::thread::hardware_concurrency(), <a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> tf=<a class="el" href="namespaceyaclib.html#a6470522549981a792f7a073772ff9c57">MakeThreadFactory</a>())</td></tr>
<tr class="memdesc:abd02a3297ea3c5b6de6144c3b993d6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new ThreadPool object.  <a href="namespaceyaclib.html#abd02a3297ea3c5b6de6144c3b993d6f6">More...</a><br /></td></tr>
<tr class="separator:abd02a3297ea3c5b6de6144c3b993d6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f6096625a4dfc44a29388ec786e56d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a77f6096625a4dfc44a29388ec786e56d">SetFrequency</a> (std::uint32_t freq)</td></tr>
<tr class="memdesc:a77f6096625a4dfc44a29388ec786e56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets frequency with which fault will be injected.  <a href="namespaceyaclib.html#a77f6096625a4dfc44a29388ec786e56d">More...</a><br /></td></tr>
<tr class="separator:a77f6096625a4dfc44a29388ec786e56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72816eee66cee5d6312498ebe7ce6a71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a72816eee66cee5d6312498ebe7ce6a71">SetSleepTime</a> (std::uint32_t ns)</td></tr>
<tr class="memdesc:a72816eee66cee5d6312498ebe7ce6a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets sleep time if sleep is used instead of yield for interrupting thread execution for fault injection.  <a href="namespaceyaclib.html#a72816eee66cee5d6312498ebe7ce6a71">More...</a><br /></td></tr>
<tr class="separator:a72816eee66cee5d6312498ebe7ce6a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d3118356d40946727112c9ba5ee15f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ab1d3118356d40946727112c9ba5ee15f">SetErrorCallback</a> (<a class="el" href="namespaceyaclib.html#aa0f01e961fd6af87d533ea57d67d9f1f">LogCallback</a>)</td></tr>
<tr class="separator:ab1d3118356d40946727112c9ba5ee15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7289b6eb7cc4afaacce9d8ddeef105af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a7289b6eb7cc4afaacce9d8ddeef105af">SetInfoCallback</a> (<a class="el" href="namespaceyaclib.html#aa0f01e961fd6af87d533ea57d67d9f1f">LogCallback</a>)</td></tr>
<tr class="separator:a7289b6eb7cc4afaacce9d8ddeef105af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa59a2dd2a81594fb6d5e71f1ac3bb0"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:acfa59a2dd2a81594fb6d5e71f1ac3bb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceyaclib.html#acc4f817f4403d420b1975cce677577c2">IFuncPtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#acfa59a2dd2a81594fb6d5e71f1ac3bb0">MakeFunc</a> (Functor &amp;&amp;f)</td></tr>
<tr class="memdesc:acfa59a2dd2a81594fb6d5e71f1ac3bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classyaclib_1_1IFunc.html">IFunc</a> object from any Callable functor.  <a href="namespaceyaclib.html#acfa59a2dd2a81594fb6d5e71f1ac3bb0">More...</a><br /></td></tr>
<tr class="separator:acfa59a2dd2a81594fb6d5e71f1ac3bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacae80b7f02ca84047a9a5564af8a869"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType , typename PtrType  = ObjectType, typename... Args&gt; </td></tr>
<tr class="memitem:aacae80b7f02ca84047a9a5564af8a869"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; PtrType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aacae80b7f02ca84047a9a5564af8a869">MakeIntrusive</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:aacae80b7f02ca84047a9a5564af8a869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f58c88424862c7970f5e34368691501"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7f58c88424862c7970f5e34368691501"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a7f58c88424862c7970f5e34368691501">operator==</a> (const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7f58c88424862c7970f5e34368691501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab205ab99a80599cf567522997ba91b7b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab205ab99a80599cf567522997ba91b7b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ab205ab99a80599cf567522997ba91b7b">operator!=</a> (const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab205ab99a80599cf567522997ba91b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf5c2b342ea0d8dcc08d36a688e4002"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aadf5c2b342ea0d8dcc08d36a688e4002"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aadf5c2b342ea0d8dcc08d36a688e4002">operator==</a> (const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;lhs, U *rhs) noexcept</td></tr>
<tr class="separator:aadf5c2b342ea0d8dcc08d36a688e4002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad623d6b5af5166e2129c5e7c524ac7a8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad623d6b5af5166e2129c5e7c524ac7a8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ad623d6b5af5166e2129c5e7c524ac7a8">operator!=</a> (const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;lhs, U *rhs) noexcept</td></tr>
<tr class="separator:ad623d6b5af5166e2129c5e7c524ac7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a93f75dbd32dff52a60d524c1a96db"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a06a93f75dbd32dff52a60d524c1a96db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a06a93f75dbd32dff52a60d524c1a96db">operator==</a> (T *lhs, const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a06a93f75dbd32dff52a60d524c1a96db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e502d06dc99e7d95a4b94cf92c0e7b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa3e502d06dc99e7d95a4b94cf92c0e7b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aa3e502d06dc99e7d95a4b94cf92c0e7b">operator!=</a> (T *lhs, const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa3e502d06dc99e7d95a4b94cf92c0e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6c964d5e75d8d4f77e77367eda447f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff6c964d5e75d8d4f77e77367eda447f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aff6c964d5e75d8d4f77e77367eda447f">operator==</a> (const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:aff6c964d5e75d8d4f77e77367eda447f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e76ea36acc0b15ff59f471dde2f1bf6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e76ea36acc0b15ff59f471dde2f1bf6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a7e76ea36acc0b15ff59f471dde2f1bf6">operator==</a> (std::nullptr_t, const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7e76ea36acc0b15ff59f471dde2f1bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db9bf2206ad479e4672445453581c4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6db9bf2206ad479e4672445453581c4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a6db9bf2206ad479e4672445453581c4a">operator!=</a> (const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a6db9bf2206ad479e4672445453581c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f85de6a478cf2b7036bbaf9b7f5243"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4f85de6a478cf2b7036bbaf9b7f5243"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ab4f85de6a478cf2b7036bbaf9b7f5243">operator!=</a> (std::nullptr_t, const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab4f85de6a478cf2b7036bbaf9b7f5243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c5d80129106db68da58a29eb4c96fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a32c5d80129106db68da58a29eb4c96fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a32c5d80129106db68da58a29eb4c96fa">operator&lt;</a> (const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a32c5d80129106db68da58a29eb4c96fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6f076aaf64ec86cd6aef4cef9f80fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba6f076aaf64ec86cd6aef4cef9f80fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#aba6f076aaf64ec86cd6aef4cef9f80fa">Check</a> () noexcept</td></tr>
<tr class="separator:aba6f076aaf64ec86cd6aef4cef9f80fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3cc59594eb77f82b357ffd894486c506"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Arg&gt; </td></tr>
<tr class="memitem:a3cc59594eb77f82b357ffd894486c506"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a3cc59594eb77f82b357ffd894486c506">is_invocable_v</a> = <a class="el" href="structyaclib_1_1detail_1_1IsInvocable.html">detail::IsInvocable</a>&lt;Functor, Arg...&gt;::Value</td></tr>
<tr class="separator:a3cc59594eb77f82b357ffd894486c506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce1ff71818739a9a00c65a185cf64ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ce1ff71818739a9a00c65a185cf64ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a2ce1ff71818739a9a00c65a185cf64ff">is_result_v</a> = <a class="el" href="structyaclib_1_1detail_1_1IsInstantiationOf.html">detail::IsInstantiationOf</a>&lt;<a class="el" href="classyaclib_1_1Result.html">Result</a>, T&gt;::Value</td></tr>
<tr class="separator:a2ce1ff71818739a9a00c65a185cf64ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5a091f19cc9cd3aea766425d16a480"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf5a091f19cc9cd3aea766425d16a480"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#acf5a091f19cc9cd3aea766425d16a480">is_future_v</a> = <a class="el" href="structyaclib_1_1detail_1_1IsInstantiationOf.html">detail::IsInstantiationOf</a>&lt;<a class="el" href="classyaclib_1_1Future.html">Future</a>, T&gt;::Value</td></tr>
<tr class="separator:acf5a091f19cc9cd3aea766425d16a480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a092a3634c0dc5d4cbbeeda54c2d52"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classyaclib_1_1Inline.html">Inline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a27a092a3634c0dc5d4cbbeeda54c2d52">sInline</a></td></tr>
<tr class="separator:a27a092a3634c0dc5d4cbbeeda54c2d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760205eed7cc2258fc445c07ba0b9e64"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceyaclib.html#aa0f01e961fd6af87d533ea57d67d9f1f">LogCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#a760205eed7cc2258fc445c07ba0b9e64">g_error_callback</a> = nullptr</td></tr>
<tr class="separator:a760205eed7cc2258fc445c07ba0b9e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47e621912a884acdce4e8632021139b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceyaclib.html#aa0f01e961fd6af87d533ea57d67d9f1f">LogCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyaclib.html#ae47e621912a884acdce4e8632021139b">g_info_callback</a> = nullptr</td></tr>
<tr class="separator:ae47e621912a884acdce4e8632021139b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac7d7025bade30573019dc58b09e29fd0" name="ac7d7025bade30573019dc58b09e29fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d7025bade30573019dc58b09e29fd0">&#9670;&nbsp;</a></span>Contract</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#ac7d7025bade30573019dc58b09e29fd0">yaclib::Contract</a> = typedef std::pair&lt;<a class="el" href="classyaclib_1_1Future.html">Future</a>&lt;V, E&gt;, <a class="el" href="classyaclib_1_1Promise.html">Promise</a>&lt;V, E&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes channel with future and promise. </p>

<p class="definition">Definition at line <a class="el" href="contract_8hpp_source.html#l00011">11</a> of file <a class="el" href="contract_8hpp_source.html">contract.hpp</a>.</p>

</div>
</div>
<a id="a83a8bd10224b9153070612f2e21e7dd4" name="a83a8bd10224b9153070612f2e21e7dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a8bd10224b9153070612f2e21e7dd4">&#9670;&nbsp;</a></span>future_error_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#a83a8bd10224b9153070612f2e21e7dd4">yaclib::future_error_t</a> = typedef typename <a class="el" href="structyaclib_1_1detail_1_1InstantiationTypes.html">detail::InstantiationTypes</a>&lt;<a class="el" href="classyaclib_1_1Future.html">Future</a>, T&gt;::Error</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00037">37</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a02d12f23257fc6bdd425efef19966548" name="a02d12f23257fc6bdd425efef19966548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d12f23257fc6bdd425efef19966548">&#9670;&nbsp;</a></span>future_value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#a02d12f23257fc6bdd425efef19966548">yaclib::future_value_t</a> = typedef typename <a class="el" href="structyaclib_1_1detail_1_1InstantiationTypes.html">detail::InstantiationTypes</a>&lt;<a class="el" href="classyaclib_1_1Future.html">Future</a>, T&gt;::Value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00034">34</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a23af97c15e210af60f48dba5fa3736b7" name="a23af97c15e210af60f48dba5fa3736b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23af97c15e210af60f48dba5fa3736b7">&#9670;&nbsp;</a></span>head_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#a23af97c15e210af60f48dba5fa3736b7">yaclib::head_t</a> = typedef typename <a class="el" href="structyaclib_1_1detail_1_1Head.html">detail::Head</a>&lt;Args...&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00013">13</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aeb00951a7b082d1c3069a02f12713018" name="aeb00951a7b082d1c3069a02f12713018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb00951a7b082d1c3069a02f12713018">&#9670;&nbsp;</a></span>IExecutorPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">yaclib::IExecutorPtr</a> = typedef <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt;<a class="el" href="classyaclib_1_1IExecutor.html">IExecutor</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="executor_8hpp_source.html#l00039">39</a> of file <a class="el" href="executor_8hpp_source.html">executor.hpp</a>.</p>

</div>
</div>
<a id="acc4f817f4403d420b1975cce677577c2" name="acc4f817f4403d420b1975cce677577c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4f817f4403d420b1975cce677577c2">&#9670;&nbsp;</a></span>IFuncPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#acc4f817f4403d420b1975cce677577c2">yaclib::IFuncPtr</a> = typedef <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt;<a class="el" href="classyaclib_1_1IFunc.html">IFunc</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="func_8hpp_source.html#l00022">22</a> of file <a class="el" href="func_8hpp_source.html">func.hpp</a>.</p>

</div>
</div>
<a id="af445c7d079358d21fa8defe06ee4ac1c" name="af445c7d079358d21fa8defe06ee4ac1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af445c7d079358d21fa8defe06ee4ac1c">&#9670;&nbsp;</a></span>invoke_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#af445c7d079358d21fa8defe06ee4ac1c">yaclib::invoke_t</a> = typedef typename <a class="el" href="structyaclib_1_1detail_1_1Invoke.html">detail::Invoke</a>&lt;Functor, Arg...&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00019">19</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ae19c41352ffc16128cc00318a4f8615c" name="ae19c41352ffc16128cc00318a4f8615c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19c41352ffc16128cc00318a4f8615c">&#9670;&nbsp;</a></span>IThreadFactoryPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">yaclib::IThreadFactoryPtr</a> = typedef <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt;<a class="el" href="classyaclib_1_1IThreadFactory.html">IThreadFactory</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8hpp_source.html#l00026">26</a> of file <a class="el" href="thread__factory_8hpp_source.html">thread_factory.hpp</a>.</p>

</div>
</div>
<a id="ab039debaa8307cdefe0c03481b1bf3da" name="ab039debaa8307cdefe0c03481b1bf3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab039debaa8307cdefe0c03481b1bf3da">&#9670;&nbsp;</a></span>IThreadPoolPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#ab039debaa8307cdefe0c03481b1bf3da">yaclib::IThreadPoolPtr</a> = typedef <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt;<a class="el" href="classyaclib_1_1IThreadPool.html">IThreadPool</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00042">42</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="a85c3cb3b321f85b6e96b47e50f6e0b0d" name="a85c3cb3b321f85b6e96b47e50f6e0b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c3cb3b321f85b6e96b47e50f6e0b0d">&#9670;&nbsp;</a></span>IThreadPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#a85c3cb3b321f85b6e96b47e50f6e0b0d">yaclib::IThreadPtr</a> = typedef <a class="el" href="classyaclib_1_1IThread.html">IThread</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8hpp_source.html#l00017">17</a> of file <a class="el" href="thread__factory_8hpp_source.html">thread_factory.hpp</a>.</p>

</div>
</div>
<a id="aa0f01e961fd6af87d533ea57d67d9f1f" name="aa0f01e961fd6af87d533ea57d67d9f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f01e961fd6af87d533ea57d67d9f1f">&#9670;&nbsp;</a></span>LogCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#aa0f01e961fd6af87d533ea57d67d9f1f">yaclib::LogCallback</a> = typedef void (*)(std::string_view file, std::size_t line, std::string_view function, std::string_view condition, std::string_view message)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="log_8hpp_source.html#l00019">19</a> of file <a class="el" href="log_8hpp_source.html">log.hpp</a>.</p>

</div>
</div>
<a id="ae47bee250bfd56f471dc072f0f5be0fc" name="ae47bee250bfd56f471dc072f0f5be0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47bee250bfd56f471dc072f0f5be0fc">&#9670;&nbsp;</a></span>result_error_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#ae47bee250bfd56f471dc072f0f5be0fc">yaclib::result_error_t</a> = typedef typename <a class="el" href="structyaclib_1_1detail_1_1InstantiationTypes.html">detail::InstantiationTypes</a>&lt;<a class="el" href="classyaclib_1_1Result.html">Result</a>, T&gt;::Error</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00028">28</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="adc8180a184a21b384fe5c6c35eb5bb9f" name="adc8180a184a21b384fe5c6c35eb5bb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8180a184a21b384fe5c6c35eb5bb9f">&#9670;&nbsp;</a></span>result_value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceyaclib.html#adc8180a184a21b384fe5c6c35eb5bb9f">yaclib::result_value_t</a> = typedef typename <a class="el" href="structyaclib_1_1detail_1_1InstantiationTypes.html">detail::InstantiationTypes</a>&lt;<a class="el" href="classyaclib_1_1Result.html">Result</a>, T&gt;::Value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00025">25</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a931c767f78cbcd6634cbedbddf405017" name="a931c767f78cbcd6634cbedbddf405017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931c767f78cbcd6634cbedbddf405017">&#9670;&nbsp;</a></span>ResultState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceyaclib.html#a931c767f78cbcd6634cbedbddf405017">yaclib::ResultState</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a931c767f78cbcd6634cbedbddf405017a689202409e48743b914713f96d93947c" name="a931c767f78cbcd6634cbedbddf405017a689202409e48743b914713f96d93947c"></a>Value&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a931c767f78cbcd6634cbedbddf405017ab0d4998a26f5b5742ad38c4af8817e32" name="a931c767f78cbcd6634cbedbddf405017ab0d4998a26f5b5742ad38c4af8817e32"></a>Exception&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a931c767f78cbcd6634cbedbddf405017a902b0d55fddef6f8d651fe1035b7d4bd" name="a931c767f78cbcd6634cbedbddf405017a902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a931c767f78cbcd6634cbedbddf405017ace2c8aed9c2fa0cfbed56cbda4d8bf07" name="a931c767f78cbcd6634cbedbddf405017ace2c8aed9c2fa0cfbed56cbda4d8bf07"></a>Empty&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="result_8hpp_source.html#l00015">15</a> of file <a class="el" href="result_8hpp_source.html">result.hpp</a>.</p>

</div>
</div>
<a id="a59284220f851121992ca16d23bc968dc" name="a59284220f851121992ca16d23bc968dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59284220f851121992ca16d23bc968dc">&#9670;&nbsp;</a></span>WhenPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dc">yaclib::WhenPolicy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This Policy describe how When* algorithm interpret if <a class="el" href="classyaclib_1_1Future.html" title="Provides a mechanism to access the result of async operations.">Future</a> will be fulfilled by error or exception. </p>
<p >None &ndash; Fail same as Ok FirstFail &ndash; save first fail LastFail &ndash; save last fail </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a59284220f851121992ca16d23bc968dca6adf97f83acf6453d4a6a4b1070f3754" name="a59284220f851121992ca16d23bc968dca6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a59284220f851121992ca16d23bc968dca1a5d257dfef0fee3c8b56cdcc2de854b" name="a59284220f851121992ca16d23bc968dca1a5d257dfef0fee3c8b56cdcc2de854b"></a>FirstFail&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a59284220f851121992ca16d23bc968dca390c1dbd73f79789d71c350562508932" name="a59284220f851121992ca16d23bc968dca390c1dbd73f79789d71c350562508932"></a>LastFail&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="when__policy_8hpp_source.html#l00014">14</a> of file <a class="el" href="when__policy_8hpp_source.html">when_policy.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a97d4007c8e7b7cc6d37389ac5c1806fa" name="a97d4007c8e7b7cc6d37389ac5c1806fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d4007c8e7b7cc6d37389ac5c1806fa">&#9670;&nbsp;</a></span>Await() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... V, typename... E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyaclib_1_1detail_1_1FutureAwaiter.html">detail::FutureAwaiter</a> yaclib::Await </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; V, E &gt; &amp;...&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="await_8hpp_source.html#l00013">13</a> of file <a class="el" href="await_8hpp_source.html">await.hpp</a>.</p>

</div>
</div>
<a id="aef9d19b82b05068a634f6557f83c1fa7" name="aef9d19b82b05068a634f6557f83c1fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9d19b82b05068a634f6557f83c1fa7">&#9670;&nbsp;</a></span>Await() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#acf5a091f19cc9cd3aea766425d16a480">is_future_v</a>&lt; Iterator &gt;, <a class="el" href="classyaclib_1_1detail_1_1FutureAwaiter.html">detail::FutureAwaiter</a> &gt; yaclib::Await </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="await_8hpp_source.html#l00018">18</a> of file <a class="el" href="await_8hpp_source.html">await.hpp</a>.</p>

</div>
</div>
<a id="ad503b0971a037bbd04d444e81a5e0150" name="ad503b0971a037bbd04d444e81a5e0150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad503b0971a037bbd04d444e81a5e0150">&#9670;&nbsp;</a></span>Await() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#acf5a091f19cc9cd3aea766425d16a480">is_future_v</a>&lt; Iterator &gt;, <a class="el" href="classyaclib_1_1detail_1_1FutureAwaiter.html">detail::FutureAwaiter</a> &gt; yaclib::Await </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="await_8hpp_source.html#l00023">23</a> of file <a class="el" href="await_8hpp_source.html">await.hpp</a>.</p>

</div>
</div>
<a id="aba6f076aaf64ec86cd6aef4cef9f80fa" name="aba6f076aaf64ec86cd6aef4cef9f80fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6f076aaf64ec86cd6aef4cef9f80fa">&#9670;&nbsp;</a></span>Check()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool yaclib::Check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00040">40</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a60e27483f912682aad998898f42b775f" name="a60e27483f912682aad998898f42b775f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e27483f912682aad998898f42b775f">&#9670;&nbsp;</a></span>CurrentThreadPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyaclib_1_1IThreadPool.html">IThreadPool</a> * yaclib::CurrentThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Thread local pointer to the ThreadPool that owns the current thread nullptr if no ThreadPool owns the thread </dd></dl>

<p class="definition">Definition at line <a class="el" href="src_2executor_2thread__pool_8cpp_source.html#l00138">138</a> of file <a class="el" href="src_2executor_2thread__pool_8cpp_source.html">thread_pool.cpp</a>.</p>

</div>
</div>
<a id="ac918e7a0c384bcf611e0b5b4b2cd5504" name="ac918e7a0c384bcf611e0b5b4b2cd5504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac918e7a0c384bcf611e0b5b4b2cd5504">&#9670;&nbsp;</a></span>MakeContract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename E  = StopError&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#ac7d7025bade30573019dc58b09e29fd0">Contract</a>&lt; V, E &gt; yaclib::MakeContract </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates related future and promise. </p>
<dl class="section return"><dt>Returns</dt><dd>a </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceyaclib.html#ac7d7025bade30573019dc58b09e29fd0" title="Describes channel with future and promise.">Contract</a> object with new future and promise </dd></dl>

<p class="definition">Definition at line <a class="el" href="contract_8hpp_source.html#l00020">20</a> of file <a class="el" href="contract_8hpp_source.html">contract.hpp</a>.</p>

</div>
</div>
<a id="acfa59a2dd2a81594fb6d5e71f1ac3bb0" name="acfa59a2dd2a81594fb6d5e71f1ac3bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa59a2dd2a81594fb6d5e71f1ac3bb0">&#9670;&nbsp;</a></span>MakeFunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#acc4f817f4403d420b1975cce677577c2">IFuncPtr</a> yaclib::MakeFunc </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1IFunc.html">IFunc</a> object from any Callable functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Callable object </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="func_8hpp_source.html#l00030">30</a> of file <a class="el" href="func_8hpp_source.html">func.hpp</a>.</p>

</div>
</div>
<a id="abaf4462ab5b93960f89cee782fdb67a5" name="abaf4462ab5b93960f89cee782fdb67a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf4462ab5b93960f89cee782fdb67a5">&#9670;&nbsp;</a></span>MakeFuture()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = Unit, typename E  = StopError, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::MakeFuture </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="future_8hpp_source.html#l00184">184</a> of file <a class="el" href="future_8hpp_source.html">future.hpp</a>.</p>

</div>
</div>
<a id="ab247a06a303af6a2234d2247eb0d1e55" name="ab247a06a303af6a2234d2247eb0d1e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab247a06a303af6a2234d2247eb0d1e55">&#9670;&nbsp;</a></span>MakeInline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a> yaclib::MakeInline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get <a class="el" href="classyaclib_1_1Inline.html">Inline</a> executor singleton object. </p>
<p >This executor immediately executes given Callable object in the same OS thread without any overhead. So it always return false from Submit, we only call Call, no submit </p><dl class="section note"><dt>Note</dt><dd>This object is useful as safe default executor value. See example.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> task = [] {};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Without inline executor:</span></div>
<div class="line"><a class="code hl_typedef" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a> executor = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="keywordflow">if</span> (...) {</div>
<div class="line">  executor = <a class="code hl_function" href="namespaceyaclib.html#abd02a3297ea3c5b6de6144c3b993d6f6">MakeThreadPool</a>(4);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (executor) {</div>
<div class="line">  executor-&gt;Submit(task);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  a();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// With inline executor:</span></div>
<div class="line"><a class="code hl_typedef" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a> executor = MakeInlineExecutor();</div>
<div class="line"><span class="keywordflow">if</span> (...) {</div>
<div class="line">  executor = <a class="code hl_function" href="namespaceyaclib.html#abd02a3297ea3c5b6de6144c3b993d6f6">MakeThreadPool</a>(4);</div>
<div class="line">}</div>
<div class="line">executor-&gt;Submit(task);</div>
<div class="ttc" id="anamespaceyaclib_html_abd02a3297ea3c5b6de6144c3b993d6f6"><div class="ttname"><a href="namespaceyaclib.html#abd02a3297ea3c5b6de6144c3b993d6f6">yaclib::MakeThreadPool</a></div><div class="ttdeci">IThreadPoolPtr MakeThreadPool(std::size_t threads=std::thread::hardware_concurrency(), IThreadFactoryPtr tf=MakeThreadFactory())</div><div class="ttdoc">Create new ThreadPool object.</div><div class="ttdef"><b>Definition:</b> <a href="src_2executor_2thread__pool_8cpp_source.html#l00142">thread_pool.cpp:142</a></div></div>
<div class="ttc" id="anamespaceyaclib_html_aeb00951a7b082d1c3069a02f12713018"><div class="ttname"><a href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">yaclib::IExecutorPtr</a></div><div class="ttdeci">IntrusivePtr&lt; IExecutor &gt; IExecutorPtr</div><div class="ttdef"><b>Definition:</b> <a href="executor_8hpp_source.html#l00039">executor.hpp:39</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="inline_8cpp_source.html#l00027">27</a> of file <a class="el" href="inline_8cpp_source.html">inline.cpp</a>.</p>

<p class="reference">References <a class="el" href="inline_8cpp_source.html#l00025">sInline</a>.</p>

</div>
</div>
<a id="aacae80b7f02ca84047a9a5564af8a869" name="aacae80b7f02ca84047a9a5564af8a869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacae80b7f02ca84047a9a5564af8a869">&#9670;&nbsp;</a></span>MakeIntrusive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType , typename PtrType  = ObjectType, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; PtrType &gt; yaclib::MakeIntrusive </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="helper_8hpp_source.html#l00011">11</a> of file <a class="el" href="helper_8hpp_source.html">helper.hpp</a>.</p>

</div>
</div>
<a id="a7f7d050cd191bf12f4b29b3f97050c83" name="a7f7d050cd191bf12f4b29b3f97050c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7d050cd191bf12f4b29b3f97050c83">&#9670;&nbsp;</a></span>MakeStrand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a> yaclib::MakeStrand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strand is the asynchronous analogue of a mutex. </p>
<p >It guarantees that the tasks scheduled for it will be executed strictly sequentially. Strand itself does not have its own threads, it decorates another executor and uses it to run its tasks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>executor to decorate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to new Strand instance </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="simple_8cpp-example.html#a12">simple.cpp</a>, and <a class="el" href="strand_8cpp-example.html#a2">strand.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="src_2executor_2strand_8cpp_source.html#l00078">78</a> of file <a class="el" href="src_2executor_2strand_8cpp_source.html">strand.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="test_2example_2executor_2strand_8cpp_source.html#l00021">TEST()</a>.</p>

</div>
</div>
<a id="a3a3348b06a8925f35eb031e9563b1980" name="a3a3348b06a8925f35eb031e9563b1980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3348b06a8925f35eb031e9563b1980">&#9670;&nbsp;</a></span>MakeThreadFactory() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> yaclib::MakeThreadFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#acc4f817f4403d420b1975cce677577c2">IFuncPtr</a>&#160;</td>
          <td class="paramname"><em>acquire</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#acc4f817f4403d420b1975cce677577c2">IFuncPtr</a>&#160;</td>
          <td class="paramname"><em>release</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8cpp_source.html#l00366">366</a> of file <a class="el" href="thread__factory_8cpp_source.html">thread_factory.cpp</a>.</p>

</div>
</div>
<a id="a58431cd89c902b17a1f386e2be4f4d33" name="a58431cd89c902b17a1f386e2be4f4d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58431cd89c902b17a1f386e2be4f4d33">&#9670;&nbsp;</a></span>MakeThreadFactory() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> yaclib::MakeThreadFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8cpp_source.html#l00358">358</a> of file <a class="el" href="thread__factory_8cpp_source.html">thread_factory.cpp</a>.</p>

</div>
</div>
<a id="a0ba22a625dc73cea7f6310d6e6147aa3" name="a0ba22a625dc73cea7f6310d6e6147aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba22a625dc73cea7f6310d6e6147aa3">&#9670;&nbsp;</a></span>MakeThreadFactory() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> yaclib::MakeThreadFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8cpp_source.html#l00362">362</a> of file <a class="el" href="thread__factory_8cpp_source.html">thread_factory.cpp</a>.</p>

</div>
</div>
<a id="a6470522549981a792f7a073772ff9c57" name="a6470522549981a792f7a073772ff9c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6470522549981a792f7a073772ff9c57">&#9670;&nbsp;</a></span>MakeThreadFactory() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a> yaclib::MakeThreadFactory </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cache</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__factory_8cpp_source.html#l00350">350</a> of file <a class="el" href="thread__factory_8cpp_source.html">thread_factory.cpp</a>.</p>

</div>
</div>
<a id="abd02a3297ea3c5b6de6144c3b993d6f6" name="abd02a3297ea3c5b6de6144c3b993d6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd02a3297ea3c5b6de6144c3b993d6f6">&#9670;&nbsp;</a></span>MakeThreadPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#ab039debaa8307cdefe0c03481b1bf3da">IThreadPoolPtr</a> yaclib::MakeThreadPool </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>threads</em> = <code>std::thread::hardware_concurrency()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#ae19c41352ffc16128cc00318a4f8615c">IThreadFactoryPtr</a>&#160;</td>
          <td class="paramname"><em>tf</em> = <code><a class="el" href="namespaceyaclib.html#a6470522549981a792f7a073772ff9c57">MakeThreadFactory</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create new ThreadPool object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threads</td><td>the number of threads to create for this ThreadPool </td></tr>
    <tr><td class="paramname">tf</td><td>thread factory to use for thread creation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classyaclib_1_1IThreadFactory.html">IThreadFactory</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>intrusive pointer to the new ThreadPool </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="simple_8cpp-example.html#a2">simple.cpp</a>, <a class="el" href="strand_8cpp-example.html#a1">strand.cpp</a>, <a class="el" href="thread_pool_8cpp-example.html#a1">thread_pool.cpp</a>, <a class="el" href="when_all_8cpp-example.html#a2">when_all.cpp</a>, and <a class="el" href="when_any_8cpp-example.html#a2">when_any.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="src_2executor_2thread__pool_8cpp_source.html#l00142">142</a> of file <a class="el" href="src_2executor_2thread__pool_8cpp_source.html">thread_pool.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="test_2example_2executor_2strand_8cpp_source.html#l00021">TEST()</a>.</p>

</div>
</div>
<a id="ab205ab99a80599cf567522997ba91b7b" name="ab205ab99a80599cf567522997ba91b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab205ab99a80599cf567522997ba91b7b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00069">69</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="a6db9bf2206ad479e4672445453581c4a" name="a6db9bf2206ad479e4672445453581c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db9bf2206ad479e4672445453581c4a">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00103">103</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="ad623d6b5af5166e2129c5e7c524ac7a8" name="ad623d6b5af5166e2129c5e7c524ac7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad623d6b5af5166e2129c5e7c524ac7a8">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00079">79</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="ab4f85de6a478cf2b7036bbaf9b7f5243" name="ab4f85de6a478cf2b7036bbaf9b7f5243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f85de6a478cf2b7036bbaf9b7f5243">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00108">108</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="aa3e502d06dc99e7d95a4b94cf92c0e7b" name="aa3e502d06dc99e7d95a4b94cf92c0e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e502d06dc99e7d95a4b94cf92c0e7b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator!= </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00089">89</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="a32c5d80129106db68da58a29eb4c96fa" name="a32c5d80129106db68da58a29eb4c96fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c5d80129106db68da58a29eb4c96fa">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00113">113</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="a7f58c88424862c7970f5e34368691501" name="a7f58c88424862c7970f5e34368691501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f58c88424862c7970f5e34368691501">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00065">65</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

<p class="reference">References <a class="el" href="intrusive__ptr__impl_8hpp_source.html#l00080">yaclib::IntrusivePtr&lt; T &gt;::Get()</a>.</p>

</div>
</div>
<a id="aff6c964d5e75d8d4f77e77367eda447f" name="aff6c964d5e75d8d4f77e77367eda447f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6c964d5e75d8d4f77e77367eda447f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00093">93</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="aadf5c2b342ea0d8dcc08d36a688e4002" name="aadf5c2b342ea0d8dcc08d36a688e4002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf5c2b342ea0d8dcc08d36a688e4002">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00074">74</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="a7e76ea36acc0b15ff59f471dde2f1bf6" name="a7e76ea36acc0b15ff59f471dde2f1bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e76ea36acc0b15ff59f471dde2f1bf6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00098">98</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="a06a93f75dbd32dff52a60d524c1a96db" name="a06a93f75dbd32dff52a60d524c1a96db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a93f75dbd32dff52a60d524c1a96db">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::operator== </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyaclib_1_1IntrusivePtr.html">IntrusivePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="intrusive__ptr_8hpp_source.html#l00084">84</a> of file <a class="el" href="intrusive__ptr_8hpp_source.html">intrusive_ptr.hpp</a>.</p>

</div>
</div>
<a id="a1842c635072fa265d437b4f21b91287f" name="a1842c635072fa265d437b4f21b91287f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1842c635072fa265d437b4f21b91287f">&#9670;&nbsp;</a></span>Run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E  = StopError, typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::Run </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute Callable functor via executor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>executor to be used to execute f and saved as callback executor for return <a class="el" href="classyaclib_1_1Future.html">Future</a> </td></tr>
    <tr><td class="paramname">f</td><td>functor to execute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classyaclib_1_1Future.html">Future</a> corresponding f return value </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="simple_8cpp-example.html#a3">simple.cpp</a>, <a class="el" href="when_all_8cpp-example.html#a3">when_all.cpp</a>, and <a class="el" href="when_any_8cpp-example.html#a3">when_any.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="run_8hpp_source.html#l00020">20</a> of file <a class="el" href="run_8hpp_source.html">run.hpp</a>.</p>

<p class="reference">References <a class="el" href="classyaclib_1_1IExecutor.html#adad1d029ecaf5a6291401978d4c38802a0125cf5f3ca38b312ca5d3b511c45a13">yaclib::IExecutor::Inline</a>, <a class="el" href="classyaclib_1_1IExecutor.html#aa0ba843e6f3b8a7bf89d431f6081e262">yaclib::IExecutor::Submit()</a>, <a class="el" href="classyaclib_1_1IExecutor.html#ad4e7a10fd641ca5fcf91d2aeb96da822">yaclib::IExecutor::Tag()</a>, <a class="el" href="log_8hpp_source.html#l00040">YACLIB_ERROR</a>, and <a class="el" href="log_8hpp_source.html#l00065">YACLIB_INFO</a>.</p>

<p class="reference">Referenced by <a class="el" href="simple_8cpp_source.html#l00122">CalculatorService::Double()</a>, <a class="el" href="simple_8cpp_source.html#l00116">CalculatorService::Increment()</a>, and <a class="el" href="simple_8cpp_source.html#l00039">TEST()</a>.</p>

</div>
</div>
<a id="ab1d3118356d40946727112c9ba5ee15f" name="ab1d3118356d40946727112c9ba5ee15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d3118356d40946727112c9ba5ee15f">&#9670;&nbsp;</a></span>SetErrorCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yaclib::SetErrorCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#aa0f01e961fd6af87d533ea57d67d9f1f">LogCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="log_8hpp_source.html#l00042">42</a> of file <a class="el" href="log_8hpp_source.html">log.hpp</a>.</p>

</div>
</div>
<a id="a77f6096625a4dfc44a29388ec786e56d" name="a77f6096625a4dfc44a29388ec786e56d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f6096625a4dfc44a29388ec786e56d">&#9670;&nbsp;</a></span>SetFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yaclib::SetFrequency </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>freq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets frequency with which fault will be injected. </p>
<p >Default is 16. </p>

<p class="definition">Definition at line <a class="el" href="fault__config_8cpp_source.html#l00010">10</a> of file <a class="el" href="fault__config_8cpp_source.html">fault_config.cpp</a>.</p>

<p class="reference">References <a class="el" href="yielder_8cpp_source.html#l00038">yaclib::detail::Yielder::SetFrequency()</a>.</p>

</div>
</div>
<a id="a7289b6eb7cc4afaacce9d8ddeef105af" name="a7289b6eb7cc4afaacce9d8ddeef105af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7289b6eb7cc4afaacce9d8ddeef105af">&#9670;&nbsp;</a></span>SetInfoCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void yaclib::SetInfoCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceyaclib.html#aa0f01e961fd6af87d533ea57d67d9f1f">LogCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="log_8hpp_source.html#l00067">67</a> of file <a class="el" href="log_8hpp_source.html">log.hpp</a>.</p>

</div>
</div>
<a id="a72816eee66cee5d6312498ebe7ce6a71" name="a72816eee66cee5d6312498ebe7ce6a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72816eee66cee5d6312498ebe7ce6a71">&#9670;&nbsp;</a></span>SetSleepTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yaclib::SetSleepTime </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets sleep time if sleep is used instead of yield for interrupting thread execution for fault injection. </p>
<p >Default is 200 </p>

<p class="definition">Definition at line <a class="el" href="fault__config_8cpp_source.html#l00016">16</a> of file <a class="el" href="fault__config_8cpp_source.html">fault_config.cpp</a>.</p>

<p class="reference">References <a class="el" href="yielder_8cpp_source.html#l00042">yaclib::detail::Yielder::SetSleepTime()</a>.</p>

</div>
</div>
<a id="a010f2552afaa6ac89c77820c957c2cd0" name="a010f2552afaa6ac89c77820c957c2cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010f2552afaa6ac89c77820c957c2cd0">&#9670;&nbsp;</a></span>Submit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::Submit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceyaclib.html#aeb00951a7b082d1c3069a02f12713018">IExecutorPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>executor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit given functor for details. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceyaclib.html#a010f2552afaa6ac89c77820c957c2cd0" title="Submit given functor for details.">Submit</a></dd></dl>
<p>This method creates <a class="el" href="classyaclib_1_1ITask.html" title="Callable that can be executed in an IExecutor.">ITask</a> with one allocation and call Submit(ITask) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>functor to execute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the task is accepted and scheduled for execution, false if the task is rejected </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="strand_8cpp-example.html#a3">strand.cpp</a>, and <a class="el" href="thread_pool_8cpp-example.html#a2">thread_pool.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="submit_8hpp_source.html#l00019">19</a> of file <a class="el" href="submit_8hpp_source.html">submit.hpp</a>.</p>

<p class="reference">References <a class="el" href="unique__task_8hpp_source.html#l00029">yaclib::detail::MakeUniqueTask()</a>, and <a class="el" href="classyaclib_1_1IExecutor.html#aa0ba843e6f3b8a7bf89d431f6081e262">yaclib::IExecutor::Submit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="test_2example_2executor_2strand_8cpp_source.html#l00021">TEST()</a>.</p>

</div>
</div>
<a id="a027cc00296224d649cadb5f0107761d8" name="a027cc00296224d649cadb5f0107761d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027cc00296224d649cadb5f0107761d8">&#9670;&nbsp;</a></span>Wait() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::DefaultEvent, typename... V, typename... E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yaclib::Wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; V, E &gt; &amp;...&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until Ready becomes true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>one or more futures to wait </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wait_8hpp_source.html#l00017">17</a> of file <a class="el" href="wait_8hpp_source.html">wait.hpp</a>.</p>

<p class="reference">References <a class="el" href="future__impl_8hpp_source.html#l00299">yaclib::Future&lt; V, E &gt;::GetCore()</a>.</p>

</div>
</div>
<a id="a3bcc3780c2cb12e6b0876b5866c99101" name="a3bcc3780c2cb12e6b0876b5866c99101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bcc3780c2cb12e6b0876b5866c99101">&#9670;&nbsp;</a></span>Wait() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::DefaultEvent, typename It &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#acf5a091f19cc9cd3aea766425d16a480">is_future_v</a>&lt; It &gt;, void &gt; yaclib::Wait </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until Ready becomes true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to futures to wait </td></tr>
    <tr><td class="paramname">end</td><td>Iterator to futures to wait </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wait_8hpp_source.html#l00028">28</a> of file <a class="el" href="wait_8hpp_source.html">wait.hpp</a>.</p>

</div>
</div>
<a id="ac104c3932bffca9c5e21f743229d4356" name="ac104c3932bffca9c5e21f743229d4356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac104c3932bffca9c5e21f743229d4356">&#9670;&nbsp;</a></span>Wait() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::DefaultEvent, typename It &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yaclib::Wait </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until Ready becomes true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to futures to wait </td></tr>
    <tr><td class="paramname">size</td><td>count of futures to wait </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="wait_8hpp_source.html#l00041">41</a> of file <a class="el" href="wait_8hpp_source.html">wait.hpp</a>.</p>

</div>
</div>
<a id="ac255d7c2eb95767b15dc77ff93b0a661" name="ac255d7c2eb95767b15dc77ff93b0a661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac255d7c2eb95767b15dc77ff93b0a661">&#9670;&nbsp;</a></span>WaitFor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::MutexEvent, typename Rep , typename Period , typename... V, typename... E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::WaitFor </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; V, E &gt; &amp;...&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the specified timeout duration has elapsed or Ready becomes true. </p>
<p >The behavior is undefined if Valid is false before the call to this function. This function may block for longer than timeout_duration due to scheduling or resource contention delays. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_duration</td><td>maximum duration to block for </td></tr>
    <tr><td class="paramname">fs</td><td>futures to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of Ready upon exiting </dd></dl>

<p class="definition">Definition at line <a class="el" href="wait__for_8hpp_source.html#l00023">23</a> of file <a class="el" href="wait__for_8hpp_source.html">wait_for.hpp</a>.</p>

<p class="reference">References <a class="el" href="future__impl_8hpp_source.html#l00299">yaclib::Future&lt; V, E &gt;::GetCore()</a>.</p>

</div>
</div>
<a id="a80b6e206b4df56f0b8d8950f8730251a" name="a80b6e206b4df56f0b8d8950f8730251a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b6e206b4df56f0b8d8950f8730251a">&#9670;&nbsp;</a></span>WaitFor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::MutexEvent, typename Rep , typename Period , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#acf5a091f19cc9cd3aea766425d16a480">is_future_v</a>&lt; Iterator &gt;, bool &gt; yaclib::WaitFor </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the specified timeout duration has elapsed or Ready becomes true. </p>
<p >The behavior is undefined if Valid is false before the call to this function. This function may block for longer than timeout_duration due to scheduling or resource contention delays. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_duration</td><td>maximum duration to block for </td></tr>
    <tr><td class="paramname">begin</td><td>Iterator to futures to wait </td></tr>
    <tr><td class="paramname">end</td><td>Iterator to futures to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of Ready upon exiting </dd></dl>

<p class="definition">Definition at line <a class="el" href="wait__for_8hpp_source.html#l00038">38</a> of file <a class="el" href="wait__for_8hpp_source.html">wait_for.hpp</a>.</p>

</div>
</div>
<a id="a540ed994451410e0a026fa350530d598" name="a540ed994451410e0a026fa350530d598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540ed994451410e0a026fa350530d598">&#9670;&nbsp;</a></span>WaitFor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::MutexEvent, typename Rep , typename Period , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::WaitFor </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the specified timeout duration has elapsed or Ready becomes true. </p>
<p >The behavior is undefined if Valid is false before the call to this function. This function may block for longer than timeout_duration due to scheduling or resource contention delays. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_duration</td><td>maximum duration to block for </td></tr>
    <tr><td class="paramname">begin</td><td>Iterator to futures to wait </td></tr>
    <tr><td class="paramname">size</td><td>count of futures to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of Ready upon exiting </dd></dl>

<p class="definition">Definition at line <a class="el" href="wait__for_8hpp_source.html#l00056">56</a> of file <a class="el" href="wait__for_8hpp_source.html">wait_for.hpp</a>.</p>

</div>
</div>
<a id="a369fd18e0340bec757b9f84e50e4026a" name="a369fd18e0340bec757b9f84e50e4026a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369fd18e0340bec757b9f84e50e4026a">&#9670;&nbsp;</a></span>WaitUntil() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::MutexEvent, typename Clock , typename Duration , typename... V, typename... E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::WaitUntil </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; V, E &gt; &amp;...&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until specified time has been reached or Ready becomes true. </p>
<p >The behavior is undefined if Valid is false before the call to this function. This function may block for longer than until after timeout_time has been reached due to scheduling or resource contention delays. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_time</td><td>maximum time point to block until </td></tr>
    <tr><td class="paramname">fs</td><td>futures to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of Ready upon exiting </dd></dl>

<p class="definition">Definition at line <a class="el" href="wait__until_8hpp_source.html#l00024">24</a> of file <a class="el" href="wait__until_8hpp_source.html">wait_until.hpp</a>.</p>

<p class="reference">References <a class="el" href="future__impl_8hpp_source.html#l00299">yaclib::Future&lt; V, E &gt;::GetCore()</a>.</p>

</div>
</div>
<a id="a925b6c58aa4d3ee845f3177798f5feb2" name="a925b6c58aa4d3ee845f3177798f5feb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925b6c58aa4d3ee845f3177798f5feb2">&#9670;&nbsp;</a></span>WaitUntil() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::MutexEvent, typename Clock , typename Duration , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="namespaceyaclib.html#acf5a091f19cc9cd3aea766425d16a480">is_future_v</a>&lt; Iterator &gt;, bool &gt; yaclib::WaitUntil </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until specified time has been reached or Ready becomes true. </p>
<p >The behavior is undefined if Valid is false before the call to this function. This function may block for longer than until after timeout_time has been reached due to scheduling or resource contention delays. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_time</td><td>maximum time point to block until </td></tr>
    <tr><td class="paramname">begin</td><td>Iterator to futures to wait </td></tr>
    <tr><td class="paramname">end</td><td>Iterator to futures to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of Ready upon exiting </dd></dl>

<p class="definition">Definition at line <a class="el" href="wait__until_8hpp_source.html#l00040">40</a> of file <a class="el" href="wait__until_8hpp_source.html">wait_until.hpp</a>.</p>

</div>
</div>
<a id="ac7901ebb91c58d92a568ea9c4202110c" name="ac7901ebb91c58d92a568ea9c4202110c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7901ebb91c58d92a568ea9c4202110c">&#9670;&nbsp;</a></span>WaitUntil() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event  = detail::MutexEvent, typename Clock , typename Duration , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool yaclib::WaitUntil </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until specified time has been reached or Ready becomes true. </p>
<p >The behavior is undefined if Valid is false before the call to this function. This function may block for longer than until after timeout_time has been reached due to scheduling or resource contention delays. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_time</td><td>maximum time point to block until </td></tr>
    <tr><td class="paramname">begin</td><td>Iterator to futures to wait </td></tr>
    <tr><td class="paramname">size</td><td>count of futures to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of Ready upon exiting </dd></dl>

<p class="definition">Definition at line <a class="el" href="wait__until_8hpp_source.html#l00059">59</a> of file <a class="el" href="wait__until_8hpp_source.html">wait_until.hpp</a>.</p>

</div>
</div>
<a id="a4152a573b6c3b13e988d675cd15ad4d4" name="a4152a573b6c3b13e988d675cd15ad4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4152a573b6c3b13e988d675cd15ad4d4">&#9670;&nbsp;</a></span>WhenAll() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dc">WhenPolicy</a> P = WhenPolicy::FirstFail, typename V , typename E , typename... Vs, typename... Es&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::WhenAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; V, E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; Vs, Es &gt; &amp;&amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>type of value all passed futures </td></tr>
    <tr><td class="paramname">E</td><td>type of error all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head,tail</td><td>one or more futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;std::array&lt;T&gt;&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="when__all_8hpp_source.html#l00058">58</a> of file <a class="el" href="when__all_8hpp_source.html">when_all.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dca1a5d257dfef0fee3c8b56cdcc2de854b">FirstFail</a>, <a class="el" href="when__all__impl_8hpp_source.html#l00039">yaclib::detail::AllCombinator&lt; V, E, N, FutureValue &gt;::Make()</a>, and <a class="el" href="when__impl_8hpp_source.html#l00013">yaclib::detail::WhenImpl()</a>.</p>

</div>
</div>
<a id="a10d72251d76812a53dcc72a0c8dc2707" name="a10d72251d76812a53dcc72a0c8dc2707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d72251d76812a53dcc72a0c8dc2707">&#9670;&nbsp;</a></span>WhenAll() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dc">WhenPolicy</a> P = WhenPolicy::FirstFail, typename It , typename T  = typename std::iterator_traits&lt;It&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::WhenAll </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>type of passed iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,end</td><td>the range of futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;std::vector&lt;T&gt;&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="when__all_8hpp_source.html#l00041">41</a> of file <a class="el" href="when__all_8hpp_source.html">when_all.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dca1a5d257dfef0fee3c8b56cdcc2de854b">FirstFail</a>, and <a class="el" href="when__all_8hpp_source.html#l00025">WhenAll()</a>.</p>

</div>
</div>
<a id="a0c6265977faa9740c1b860d0ca400fbf" name="a0c6265977faa9740c1b860d0ca400fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6265977faa9740c1b860d0ca400fbf">&#9670;&nbsp;</a></span>WhenAll() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dc">WhenPolicy</a> P = WhenPolicy::FirstFail, typename It , typename T  = typename std::iterator_traits&lt;It&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::WhenAll </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> which will be ready when all futures are ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>type of passed iterator </td></tr>
    <tr><td class="paramname">T</td><td>type of all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,size</td><td>the range of futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;std::vector&lt;T&gt;&gt; </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="when_all_8cpp-example.html#a1">when_all.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="when__all_8hpp_source.html#l00025">25</a> of file <a class="el" href="when__all_8hpp_source.html">when_all.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dca1a5d257dfef0fee3c8b56cdcc2de854b">FirstFail</a>, and <a class="el" href="when__impl_8hpp_source.html#l00013">yaclib::detail::WhenImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="when__all_8cpp_source.html#l00024">TEST()</a>, and <a class="el" href="when__all_8hpp_source.html#l00041">WhenAll()</a>.</p>

</div>
</div>
<a id="ae3cefe429f3566431baa0f27b02f6935" name="ae3cefe429f3566431baa0f27b02f6935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cefe429f3566431baa0f27b02f6935">&#9670;&nbsp;</a></span>WhenAny() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dc">WhenPolicy</a> P = WhenPolicy::LastFail, typename V , typename E , typename... Vs, typename Es &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; V, E &gt; yaclib::WhenAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; V, E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classyaclib_1_1Future.html">Future</a>&lt; Vs, Es &gt; &amp;&amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>policy WhenAny errors </td></tr>
    <tr><td class="paramname">V</td><td>type of value all passed futures </td></tr>
    <tr><td class="paramname">E</td><td>type of error all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head,tail</td><td>one or more futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;T&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="when__any_8hpp_source.html#l00068">68</a> of file <a class="el" href="when__any_8hpp_source.html">when_any.hpp</a>.</p>

<p class="reference">References <a class="el" href="when__any__impl_8hpp_source.html#l00126">yaclib::detail::AnyCombinator&lt; V, E, P &gt;::Make()</a>, and <a class="el" href="when__impl_8hpp_source.html#l00013">yaclib::detail::WhenImpl()</a>.</p>

</div>
</div>
<a id="a8888500725b47abf63d9a187311e5501" name="a8888500725b47abf63d9a187311e5501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8888500725b47abf63d9a187311e5501">&#9670;&nbsp;</a></span>WhenAny() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dc">WhenPolicy</a> P = WhenPolicy::LastFail, typename It , typename T  = typename std::iterator_traits&lt;It&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::WhenAny </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>policy WhenAny errors </td></tr>
    <tr><td class="paramname">It</td><td>type of passed iterator </td></tr>
    <tr><td class="paramname">T</td><td>type of all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,end</td><td>the range of futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;T&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="when__any_8hpp_source.html#l00051">51</a> of file <a class="el" href="when__any_8hpp_source.html">when_any.hpp</a>.</p>

</div>
</div>
<a id="ab4f7913770512400e0808d23065cf6ea" name="ab4f7913770512400e0808d23065cf6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f7913770512400e0808d23065cf6ea">&#9670;&nbsp;</a></span>WhenAny() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceyaclib.html#a59284220f851121992ca16d23bc968dc">WhenPolicy</a> P = WhenPolicy::LastFail, typename It , typename T  = typename std::iterator_traits&lt;It&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto yaclib::WhenAny </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classyaclib_1_1Future.html">Future</a> that is ready when any of futures is ready. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>policy WhenAny errors </td></tr>
    <tr><td class="paramname">It</td><td>type of passed iterator </td></tr>
    <tr><td class="paramname">T</td><td>type of all passed futures </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,size</td><td>the range of futures to combine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;T&gt; </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="when_any_8cpp-example.html#a1">when_any.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="when__any_8hpp_source.html#l00026">26</a> of file <a class="el" href="when__any_8hpp_source.html">when_any.hpp</a>.</p>

<p class="reference">References <a class="el" href="when__any__impl_8hpp_source.html#l00126">yaclib::detail::AnyCombinator&lt; V, E, P &gt;::Make()</a>, and <a class="el" href="when__impl_8hpp_source.html#l00013">yaclib::detail::WhenImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="when__any_8cpp_source.html#l00024">TEST()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a760205eed7cc2258fc445c07ba0b9e64" name="a760205eed7cc2258fc445c07ba0b9e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760205eed7cc2258fc445c07ba0b9e64">&#9670;&nbsp;</a></span>g_error_callback</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#aa0f01e961fd6af87d533ea57d67d9f1f">LogCallback</a> yaclib::g_error_callback = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="log__error_8cpp_source.html#l00011">11</a> of file <a class="el" href="log__error_8cpp_source.html">log_error.cpp</a>.</p>

</div>
</div>
<a id="ae47e621912a884acdce4e8632021139b" name="ae47e621912a884acdce4e8632021139b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47e621912a884acdce4e8632021139b">&#9670;&nbsp;</a></span>g_info_callback</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyaclib.html#aa0f01e961fd6af87d533ea57d67d9f1f">LogCallback</a> yaclib::g_info_callback = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="log__info_8cpp_source.html#l00011">11</a> of file <a class="el" href="log__info_8cpp_source.html">log_info.cpp</a>.</p>

</div>
</div>
<a id="acf5a091f19cc9cd3aea766425d16a480" name="acf5a091f19cc9cd3aea766425d16a480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5a091f19cc9cd3aea766425d16a480">&#9670;&nbsp;</a></span>is_future_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool yaclib::is_future_v = <a class="el" href="structyaclib_1_1detail_1_1IsInstantiationOf.html">detail::IsInstantiationOf</a>&lt;<a class="el" href="classyaclib_1_1Future.html">Future</a>, T&gt;::Value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00031">31</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a3cc59594eb77f82b357ffd894486c506" name="a3cc59594eb77f82b357ffd894486c506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc59594eb77f82b357ffd894486c506">&#9670;&nbsp;</a></span>is_invocable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool yaclib::is_invocable_v = <a class="el" href="structyaclib_1_1detail_1_1IsInvocable.html">detail::IsInvocable</a>&lt;Functor, Arg...&gt;::Value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00016">16</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a2ce1ff71818739a9a00c65a185cf64ff" name="a2ce1ff71818739a9a00c65a185cf64ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce1ff71818739a9a00c65a185cf64ff">&#9670;&nbsp;</a></span>is_result_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool yaclib::is_result_v = <a class="el" href="structyaclib_1_1detail_1_1IsInstantiationOf.html">detail::IsInstantiationOf</a>&lt;<a class="el" href="classyaclib_1_1Result.html">Result</a>, T&gt;::Value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8hpp_source.html#l00022">22</a> of file <a class="el" href="type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a27a092a3634c0dc5d4cbbeeda54c2d52" name="a27a092a3634c0dc5d4cbbeeda54c2d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a092a3634c0dc5d4cbbeeda54c2d52">&#9670;&nbsp;</a></span>sInline</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classyaclib_1_1Inline.html">Inline</a> yaclib::sInline</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="inline_8cpp_source.html#l00025">25</a> of file <a class="el" href="inline_8cpp_source.html">inline.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="inline_8cpp_source.html#l00027">MakeInline()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceyaclib.html">yaclib</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
<script type="text/javascript">
  $(document).ready(function(){
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
  })
</script>
</body>
</html>
