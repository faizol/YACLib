<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YACLib: Дизайн</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YACLib
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ library for concurrent tasks execution</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_doc_design_ru.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Дизайн </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md53"></a>
Мотивация:</h1>
<p >YACLib - С++ библиотека для конкурентного и параллельного исполнения задач, которая является альтернативой для существующих решений, стремящаяся к тому, чтобы удовлетворять следующим свойствам:</p>
<ul>
<li>Easy to use</li>
<li>Zero cost abstraction</li>
<li>Easy to build</li>
<li>Good test coverage</li>
</ul>
<h2><a class="anchor" id="autotoc_md54"></a>
Easy to use:</h2>
<p >Программировать конкурентные/параллельные программы сложно, поэтому одна из наиболее важных целей, чтобы YACLib было легко использовать правильно.</p>
<p >Пример:</p>
<p >Future в нашем интерфейсе имеет две перегрузки <code>Get</code>: <code>ReturnValue Get() const &amp;</code> и <code>ReturnValue Get() &amp;&amp;</code>, а перегрузки <code>ReturnValue Get() &amp;</code> и <code>ReturnValue Get() const &amp;&amp;</code> удалены.</p>
<p >Как следствие - большая часть неправильного или неоптимального использования <code>Get</code> обнаруживается на этапе компиляции.</p>
<h2><a class="anchor" id="autotoc_md55"></a>
Zero cost abstraction:</h2>
<p >Абстракции, которые предоставляет YACLib должны делать код, оптимально написанный для конкретного случая, проще и оставлять его таким же быстрым.</p>
<p >Например, поэтому, <code>Strand::Execute(...some task...)</code> - lock-free, а создание и исполнение pipeline из Future делает ровно одну аллокацию на каждый шаг pipeline.</p>
<h2><a class="anchor" id="autotoc_md56"></a>
Easy to build:</h2>
<p >Сборка YACLib должна быть простой, так как иначе библиотеку сложно добавить в кроссплатформенные проекты. При этом сборка не должна значительно замедлять сборку целевого проекта. Поэтому мы собираем весь проект с помощью CMake как статическую библиотеку, стараясь использовать минимум публичного шаблонного кода.</p>
<h2><a class="anchor" id="autotoc_md57"></a>
Good test coverage:</h2>
<p >Самое важное - это отсутствие багов. Потому что найти многопоточный баг очень сложно, а если он в библиотеке - еще сложнее. Поэтому мы:</p>
<ul>
<li>стремимся к 100% тестовому покрытию</li>
<li>тестируем код под множеством платформ с разными флагами сборки</li>
<li>используем статические анализаторы для С++, такие, как clang-tidy, cppcheck</li>
<li>используем динамические анализаторы для С++, такие, как Google Sanitizers, Valgrind, etc</li>
</ul>
<h1><a class="anchor" id="autotoc_md58"></a>
Что уже сделано:</h1>
<h2><a class="anchor" id="autotoc_md59"></a>
Были написаны следующие абстракции:</h2>
<ol type="1">
<li>Executors:<ul>
<li>Inline</li>
<li>ThreadPool</li>
<li>Strand</li>
</ul>
</li>
<li>Future/Promise abstraction</li>
<li>Combinators:<ul>
<li>WhenAll</li>
<li>WhenAny</li>
</ul>
</li>
<li>ThreadFactory</li>
<li>Documentation, Tests, CI</li>
</ol>
<ul>
<li>### Inline Executor:</li>
</ul>
<p >Zero cost абстракция, для того, чтобы избежать лишний проверок <code>executor</code> на <code>nullptr</code>.</p>
<p >Так же это <code>executor</code> по-умолчанию для других классов.</p>
<ul>
<li>### Thread Pool Executor</li>
</ul>
<p >Абстракция, позволяющая параллельно исполнять задачи на выбранном количестве потоков. Мы написали полезные для пользователя интерфейсы остановки <code>ThreadPool</code>, потому что это одна из сложных задач в параллельном программировании:</p>
<ul>
<li><code>Stop</code> - запрещает добавлять новые задачи в <code>ThreadPool</code>, и выполняет оставшиеся.</li>
<li><code>SoftStop</code> - вызывает <code>Stop</code>, когда в <code>ThreadPool</code> не остается задач.</li>
<li><code>HardStop</code> - вызывает Stop и не выполняет оставшиеся задачи.</li>
</ul>
<p >Было принято осознанное решение разделить <code>Join</code> на <code>Stop</code> и <code>Wait</code>.</p>
<p >Также была написана почти lock-free специализация <code>ThreadPool</code> для одного потока, так как это частый случай использования <code>ThreadPool</code> в различных проектах, например: <code>UIThread, RenderThread, AnimationThread, LoggerThread, FileIOThread etc</code>. Во всех этих случаях часто пишут свой велосипед, потому что абстракция <code>ThreadPool</code> обычно слишком тяжелое решение для этой задачи, мы же улучшили производительность <code>ThreadPool</code> для одного потока, оставив такое же API.</p>
<ul>
<li>### Strand</li>
</ul>
<p >Абстракция, позволяющая сериализовать исполнение задач поверх <code>ThreadPool</code> или другого <code>Executor</code>. Это позволяет избавиться от явных блокировок (e.g. <code>std::mutex</code>) и перейти к кооперативному исполнению задач.</p>
<p >Наша реализация удовлетворяет нескольким свойствам:</p>
<ul>
<li>Полностью lock-free (при этом lock-free имплементация достаточно простая, чтобы быть эффективнее spin-lock)</li>
<li>Не занимает executor (или его поток, в случае <code>ThreadPool</code>) на неограниченное время, позволяя исполняться другим задачам, с помощью перепланирования, вместо рекурсии или цикла.</li>
<li>Bulk исполнения задач (Batching) - несколько задач исполняются подряд, что позволяет более оптимально использовать кэш процессора.</li>
</ul>
<h2><a class="anchor" id="autotoc_md60"></a>
Future/Promise/Run abstraction</h2>
<p >Абстракция для составления пайплайнов исполнения задач.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">auto thread_pool = MakeThreadPool(4);</div>
<div class="line">auto future = Run(thread_pool, task1)</div>
<div class="line">              .Then(task2)</div>
<div class="line">              .Then(task3)</div>
</div><!-- fragment --><p >Текущая имплементация удовлетворяет следующим свойствам:</p>
<ul>
<li><code>Promise::Set / Future::Then</code> - является <code>lock-free</code>, реализованным на конечном автомате на atomic.</li>
<li><code>Wait/WaitFor/WaitUntil</code> - не требуют аллокаций, что довольно нетривиально, учитывая первое свойство. (отсутствие <code>std::mutex</code> и <code>std::condition_variable</code> в <code>SharedState</code>).</li>
<li>Одна аллокация на планирование и исполнение каждого шага pipeline, что является наиболее эффективным решением, помимо <code>Lazy Future</code>.</li>
<li>Поддержка <code>Future&lt;Future&lt;T&gt;&gt; -&gt; Future&lt;T&gt;</code>.</li>
</ul>
<p >Пример:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">auto future = Run(MakeInline(), []{</div>
<div class="line">    return MakeFuture&lt;int&gt;(5); // Returns Future&lt;int&gt;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// decltype(future) == Future&lt;int&gt;</div>
</div><!-- fragment --><ul>
<li>Поддерживаем обработку ошибок, как с помощью исключений, так и с помощью кодов возврата (Error)</li>
<li>Помимо T умеем обрабатывать разные перегрузки: <code>util::Result&lt;T&gt;</code>, <code>std::exception_ptr</code>, <code>Error</code></li>
</ul>
<p >Пример:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">auto future = Run(MakeInline(), []{</div>
<div class="line">    throw std::runtime_error{&quot;bad exception&quot;};</div>
<div class="line">}).Then([](std::exception_ptr e) { // recover error</div>
<div class="line">    return 1;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(std::move(future).Get().Value() == 1);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md61"></a>
WhenAll Combinator</h2>
<p >Абстракция, позволяющая планировать продолжение сразу для набора Futures, переданных через итераторы или как variadic template parameters. Также реализована lock-free.</p>
<p >Пример:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">auto [future1, promise1] = MakeContract&lt;int&gt;();</div>
<div class="line">auto [future2, promise2] = MakeContract&lt;int&gt;();</div>
<div class="line">auto [future3, promise3] = MakeContract&lt;int&gt;();</div>
<div class="line">auto AllFuture = WhenAll(future1, future2, future3);</div>
<div class="line">// decltype(AllFuture) == Future&lt;std::array&lt;int, 3&gt;&gt;;</div>
<div class="line">assert(AllFuture.Ready() == false);</div>
<div class="line">promise1.Set(5);</div>
<div class="line">promise2.Set(3);</div>
<div class="line">assert(AllFuture.Ready() == false); // still not completed!</div>
<div class="line">promise2.Set(8);</div>
<div class="line">assert(AllFuture.Ready() == true);</div>
<div class="line"> </div>
<div class="line">// array{5, 3, 8}:</div>
<div class="line">auto result = std::move(AllFuture).Get().Value(); </div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md62"></a>
ThreadFactory</h2>
<p >Абстракция для удобно создания потоков для разных <code>ThreadPool</code>. Например, для задания:</p>
<ul>
<li>имени потокам</li>
<li>приоритета потокам</li>
<li>сallback на старте исполнения и перед окончанием потока</li>
</ul>
<p >А также имеется возможность кэширования и пере-использования потоков при использовании<code>HeavyThreadFactory</code> и нескольких <code>ThreadPool</code>.</p>
<h1><a class="anchor" id="autotoc_md63"></a>
Что планируется сделать</h1>
<h2><a class="anchor" id="autotoc_md64"></a>
Lazy Future</h2>
<p >Последние несколько лет ключевые члены комитета стандартизации C++ занимаются оптимизацией pipeline из future на этапе компиляции. (Текущее состояние предложения: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r13.html">P0443</a>). Мы хотим реализовать часть этой идеи для оптимизации pipeline <code>Futures</code>. Полностью реализовать предложение крайне сложно, много лучших C++ инженеров занимаются этим несколько лет (среди них Hans Boehm - один из авторов C++ Memory Model, Chris Kohlhoff - создатель Boost.Asio, Erich Niebler - Ranges C++20, Lewis Baker - создатель cppcoro, Gor Nishanov - создатель C++20 coroutine, etc.).</p>
<p >Мы хотим реализовать только следующие сценарии:</p>
<ul>
<li>Объединять подряд идущие <code>Future::Then</code> в одну аллокацию:</li>
</ul>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">future.Then(task1).Then(task2).Then(task3)</div>
</div><!-- fragment --><ul>
<li>Добавить <code>lazy::Run</code>, создание незапущенной Future без аллокации</li>
<li>Реализация ленивых <code>Future Combinators</code> как для <code>lazy::Future</code>, так и для <code>Future</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md65"></a>
Разные реализации ThreadPool и их бенчмарки</h1>
<p >Основной смысл задачи в написании правильный бенчмарков и различных реализаций <code>ThreadPool</code> для того, чтобы определить для каких типов задач какой <code>ThreadPool</code> наиболее оптимальный.</p>
<h2><a class="anchor" id="autotoc_md66"></a>
План реализации:</h2>
<ul>
<li>Написать хороший <code>Test And Set</code>-spinlock, убедиться, что все остальные алгоритмы spinlock плохо работают в <code>user-space</code>.</li>
<li>В дальнейшем, если мы используем <code>std::mutex</code> - мы также должны сравнивать производительность с использованием <code>spinlock</code>.</li>
<li>Реализовать стратегию <em>Work-Stealing</em> и сравнить ее производительность.</li>
<li>Реализовать стратегию <em>Work-Distribution</em> и сравнить ее производительность.</li>
<li>Реализовать <em>lock-free Michael-Scott queue</em> для планирования задач.</li>
</ul>
<p >Подробности см. в <a href="https://github.com/YACLib/YACLib/issues/4">issue</a> на github.</p>
<h1><a class="anchor" id="autotoc_md67"></a>
Fibers</h1>
<p ><code>Fiber</code>, также известные как: <code>user level threads</code>, <code>stackful coroutines</code>, <code>goroutines</code>, <code>green threads</code>. Кооперативная многозадачность полезна во множестве случаев, как правило, связанных с <code>IO-bound</code> задачами, но не обязательно.</p>
<h2><a class="anchor" id="autotoc_md68"></a>
План реализации:</h2>
<ul>
<li>Реализовать <code>Stackful coroutines</code> (<code>callable object</code>, который представляет собой вычисление, которое может останавливаться по собственной воле и возобновляться по воле вызывающего кода или внешнего события).</li>
<li>Реализовать <code>Fibers</code>, по сути являющиеся исполнениями coroutine.</li>
<li>Реализовать <code>Futex</code> для <code>Fibers</code>, не использующий системных вызовов.</li>
<li>Реализовать различные примитивы синхронизации для <code>Fibers</code>: <code>Mutex</code>, <code>ConditionVariable</code>, <code>etc</code>.</li>
<li>Реализовать lock-free <code>AsyncMutex</code>, по сути переосмысление <code>Strand</code>.</li>
<li>Реализовать каналы для передачи данных между <code>Fibers</code>: <code>Bounded/Unbounded SPSC/MPSC/SPMC/MPMC</code>, стоит попытаться реализовать <code>lock-free</code> алгоритмы.</li>
<li>Реализовать <code>select</code> для каналов.</li>
</ul>
<p >Как дополнительную задачу можно рассмотреть реализацию планировщика <code>Fibers</code>, аналогичного планировщику <code>golang</code> (<code>kotlin</code>, <code>rust tokio</code> используют такой же алгоритм).</p>
<h1><a class="anchor" id="autotoc_md70"></a>
Concurrent algorithms</h1>
<p >Для полноты библиотеки и удобства ее использования, необходимо реализовать следующие абстракции:</p>
<ul>
<li><code>Shared Future</code></li>
</ul>
<p >Аналог <code>Future</code>, у которой не константные методы - <code>thread-safe</code></p>
<ul>
<li><code>Shared Promise</code></li>
</ul>
<p >Аналог <code>Promise</code>, у которого не константные методы - <code>thread-safe</code></p>
<ul>
<li><code>WhenAny combinator</code></li>
</ul>
<p >Абстракция, позволяющая планировать продолжение для первой готовой <code>Future</code> из набора <code>Futures</code>, переданных через итераторы или как variadic template parameters. Реализация должна быть lock-free.</p>
<ul>
<li>Попробовать реализовать другие комбинаторы, такие как: <code>WhenEach</code>, <code>WhenSome</code>, <code>etc</code>.</li>
<li>Для всех комбинаторов реализовать вариант <code>Wait</code> (т.е. <code>WhenAll -&gt; WaitAll</code>), это экономит аллокацию</li>
</ul>
<h1><a class="anchor" id="autotoc_md71"></a>
Почему я должен использовать YACLib?</h1>
<p >Возможные аналоги:</p>
<ul>
<li>STL</li>
<li>OpenMP</li>
<li>oneAPI TBB (ранее известная как Intel TBB)</li>
<li>Boost.Asio</li>
<li>Folly</li>
<li>HPX</li>
<li>Boost.Fiber</li>
<li>marl</li>
<li>taskflow</li>
<li>libunifex/cppcoro</li>
</ul>
<h2><a class="anchor" id="autotoc_md72"></a>
STL</h2>
<p ><code>future/promise/packaged_task</code> не являются <code>zero cost</code> и обладают <em>easy to misuse API</em>. Также отсутствует возможность для планирования pipeline задач. Другие же примитивы слишком низкоуровневые и подходят скорее для написания собственной библиотеки, например ThreadPool.</p>
<h2><a class="anchor" id="autotoc_md73"></a>
OpenMP</h2>
<p >Хорошо подходит для вычислительных задач, когда нужно быстро попробовать распараллелить код. Однако не подходит для конкурентного исполнения задач, которое на практике встречается значительно чаще.</p>
<h2><a class="anchor" id="autotoc_md74"></a>
oneAPI TBB</h2>
<p >Библиотека, которая является более современной и хорошо написанной альтернативой OpenMP.</p>
<p >Ключевые недостатки:</p>
<ul>
<li>Довольно большая библиотека (100 тысяч LOC).</li>
<li>Обладает весьма специфичным и недружелюбным API для конкурентного исполнения задач.</li>
<li>В некоторых местах [не учитывает протокол когерентности кэшей и не оптимально использует C++ memory model] (<a href="https://github.com/oneapi-src/oneTBB/blob/40a9a1060069d37d5f66912c6ee4cf165144774b/include/oneapi/tbb/spin_mutex.h#L71">https://github.com/oneapi-src/oneTBB/blob/40a9a1060069d37d5f66912c6ee4cf165144774b/include/oneapi/tbb/spin_mutex.h#L71</a>).</li>
</ul>
<h2><a class="anchor" id="autotoc_md75"></a>
Boost.Asio</h2>
<p >Является хорошей оберткой для network platform specific API. Главный недостаток, что все остальное, не IO, написано скорее как заглушка, предполагающая, что у вас есть собственная альтернатива.</p>
<h2><a class="anchor" id="autotoc_md76"></a>
Folly</h2>
<p >Хорошая библиотека, которая обладает вполне хорошим и дружелюбным интерфейсом, однако довольно громоздкая, что не удовлетворяет <code>Easy To Build</code>. Также в нашей библиотеке мы написали более оптимально:</p>
<ul>
<li><code>Strand</code>, сделав его полностью lock-free и удовлетворяющим большему количеству свойств, например, don’t occupy thread.</li>
<li>Взаимодействие <code>Future</code> и <code>Executor</code>, уменьшив количество аллокаций, с помощью создания <em>Callable Shared State</em> для <code>Future</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md77"></a>
HPX</h2>
<p >Гигантская библиотека с очень сложной системой сборки.</p>
<h2><a class="anchor" id="autotoc_md78"></a>
Boost.Fiber и marl</h2>
<p ><code>User Level Threads (Fibers)</code> - не единственное, что необходимо в библиотеке для конкурентного и параллельного исполнения задач. В частности, Fibers не всегда подходят для CPU-bound задач, например, чтобы обрабатывать асинхронные callback внешних библиотек. Также в marl отсутствует хороший <code>user level mutex</code>, а в Boost.Fiber он не lock-free.</p>
<h2><a class="anchor" id="autotoc_md79"></a>
Taskflow</h2>
<p >Видно, что приоритетом библиотеки является распараллеливание задач с помощью CUDA, OpenCL, etc, а не конкурентное исполнение задач.</p>
<h2><a class="anchor" id="autotoc_md80"></a>
libunifex/cppcoro</h2>
<p >Обе библиотеки являются довольно инновационными и интересными, но экспериментальными. Полноценная поддержка будет добавлена в STL не раньше, чем в C++23, а наша библиотека планирует поддерживать все стандарты, начиная с C++11. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
<script type="text/javascript">
  $(document).ready(function(){
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
  })
</script>
</body>
</html>
